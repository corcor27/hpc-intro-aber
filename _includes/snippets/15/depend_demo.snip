To demonstrate, let's use `module list`. `module list` shows all loaded software modules.

```
{{ site.host_prompt }} module list
```
{: .bash}
```
Currently Loaded Modulefiles:
  1) system/auto             3) python/3.7.0
  2) compiler/intel/2018/2
```
{: .output}
Hawk:
```
{{ site.host_prompt }} module load plink
{{ site.host_prompt }} module list
```
{: .bash}
```
Currently Loaded Modulefiles:
  1) system/auto             4) mkl/2018/3
  2) compiler/intel/2018/2   5) plink/2.0
  3) python/3.7.0
```
{: .output}

Sunbird:
```
{{ site.host_prompt2 }} module load febio
{{ site.host_prompt2 }} module list
```
{: .bash}
```
Currently Loaded Modulefiles:
  1) system/auto             4) mkl/2018/3
  2) compiler/intel/2018/2   5) febio/4.0
  3) python/3.7.0
```
{: .output}


So in this case, loading the `plink` module (a bioinformatics software package) or `febio` module (medical application software package), also loaded
`mkl/2018/3` as well. Let's try unloading the `plink` or `febio` package.

Hawk:
```
{{ site.host_prompt }} module unload plink
{{ site.host_prompt }} module list
```
{: .bash}
Sunbird:
```
{{ site.host_prompt2 }} module unload febio
{{ site.host_prompt2 }} module list
```
{: .bash}
```
Currently Loaded Modulefiles:
  1) system/auto             3) mkl/2018/3
  2) compiler/intel/2018/3   4) python/3.7.0
```
{: .output}

So using `module unload` "un-loads" a module but **NOT** its dependencies.
If we wanted to unload everything at once, we could run `module purge` (unloads everything).

```
{{ site.host_prompt }} module purge
{{ site.host_prompt }} module list
```
{: .bash}
```
No Modulefiles Currently Loaded.
```
{: .output}

Note is has unloaded everything, including the original ```null``` package that was used as a placeholder for
initialisation.

